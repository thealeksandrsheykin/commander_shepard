# -*- coding: utf-8 -*-
# !/usr/bin/env python3

"""
1.Написать функцию, которая на вход будет принимать произвольное количество аргументов и возвращать их сумму.
2.В сигнатуре функции объявить 4 обязательных аргумента, но оставить возможность передавать в неё сколько угодно дополнительных аргументов.
Попробуйте вызвать функцию в следующих ситуациях и объясните результат:
    - прокинуть в функцию только 1 аргумент
    - прокинуть аргументы таким образом, чтобы обязательный аргумент был передан одновременно позиционно и по ключу
    - создать кортеж со значениями и распаковать его при вызове функции с помощью *
    - создать словарь со значениями и распаковать его при вызове функции с помощью * и **: что наблюдаете? Почему?
"""


def medium01(*args: int) -> int:
    """
    This function return sum of input data
    :param args: tuple of only integer type numbers
    :return: integer type number
    """
    return sum(args)


def medium02(a: int, b: int, c: int, d: int, *args: int) -> int:
    """
    This function return sum of input data
    :param a: integer type number
    :param b: integer type number
    :param c: integer type number
    :param d: integer type number
    :param args: tuple of only integer type numbers
    :return: integer type number
    """
    my_list = [(a, b, c, d), args]

    return sum(list(sum(my_list, ())))


if __name__ == '__main__':
    print(f'1.  {medium01(1, 2, 3, 4)}\n')
    print(f'2.  {medium02(1, 2, 3, 4, 5)}')
    try:
        print(f'2.1 {medium02(1)}')  # Если прокинуть в функцию один аргумент, то будет ошибка типа "TypeError"
    except TypeError:                # (missing 3 required positional arguments: 'b', 'c' and 'd')
        print('2.1 Failed...')       # так как у нас 4 обязательных аргумента (a,b,c,d), а мы передали только один...

    print(f'2.2 {medium02(a=6, b=7, c=8, d=9)}')  # Если прокинуть одновременно позиционно и по ключу, хотя не играет
                                                  # роли как позиционно они будут располагаться если мы задаем
                                                  # обязательные аргументы по ключу (т.е по их именам). Единственное,
                                                  # что мы теряем в этом случаем, так это задать дополнительные аргументы,
                                                  # так как после задания аргументов по ключу мы не можем передать доп.
                                                  # параметры.

    my_tuple = (10, 11, 12, 13)                   # Все работает. my_tuple c помощью "*" распаковался в переменные
    print(f'2.3.1 {medium02(*my_tuple)}')         # a,b,c,d и после можно задать еще доп. параметры
    print(f'2.3.2 {medium02(*my_tuple, 1, 2, 3)}')

    my_dict = {'a': 14, 'b': 15, 'c': 16, 'd': 17}
    print(f'2.4.1 {medium02(**my_dict)}')        # В случае распаковки словаря с помощью "**" его ключи будут сопаставлены
    try:                                         # с аргументами функции и соответственно забирут значение ключей.
        print(f'2.4.2 {medium02(*my_dict)}')     # Распакова с помощью "*" словаря вернет нам только ключи данного словаря
    except TypeError:                            # и соответсвенно будет ошибка "TypeError"
        print('2.4.2 Failed...\n')
